uint16 hits[Grayscale]={0};
float P[Grayscale]={0};
float PK[Grayscale]={0};
float MK[Grayscale]={0};
uint16 img_thrsod;
float imgsize;



void Ostu(){
    imgsize=MT9V03X_H*MT9V03X_W;
    uint16 img_temp_value;


    float sumPk=0;
    float sumMk=0;
    float var=0;
    float vartmp;
    //直方图
    for(uint16 i=0;i<Grayscale;i++){
        P[i]=0;
        PK[i]=0;
        MK[i]=0;
    }
    for(uint16 i=0;i<MT9V03X_H;i++)
            for(uint16 j=0;j<MT9V03X_W;j++){
                img_temp_value=mt9v03x_image[i][j];
            hits[img_temp_value]++;
            }
    //类间方差
    for(uint16 i=0;i<Grayscale;i++){
        P[i]=(float)hits[i]/imgsize;
        PK[i]=sumPk+P[i];
        sumPk=PK[i];
        MK[i]=sumMk+i*P[i];
        sumMk=MK[i];
    }

    for(uint16 i=5;i<245;i++)
    {
        vartmp=((MK[Grayscale-1]*PK[i]-MK[i])*(MK[Grayscale-1]*PK[i]-MK[i]))/(PK[i]*(1-PK[i]));

        if(vartmp>var){
            var=vartmp;
            img_thrsod=i;
        }
    }
    tft180_show_uint(8*0,16*7,img_thrsod,4);
    binaryzation(BAW_images,img_thrsod);

}