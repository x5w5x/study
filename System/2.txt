
uint16 hits[Grayscale] = {0};      // 灰度直方图
float P[Grayscale] = {0};         // 概率分布
float PK[Grayscale] = {0};        // 累积概率
float MK[Grayscale] = {0};        // 累积均值
uint16 img_thrsod;                // 最终计算的阈值
float imgsize;                    // 图像总像素数

void Ostu() {
    imgsize = MT9V03X_H * MT9V03X_W;
    uint16 img_temp_value;

    float sumPk = 0;    // 累积概率
    float sumMk = 0;    // 累积均值
    float var = 0;      // 最大类间方差（初始化为0）
    float vartmp;       // 临时方差

    // 1. 初始化直方图
    for (uint16 i = 0; i < Grayscale; i++) {
        hits[i] = 0;
        P[i] = 0;
        PK[i] = 0;
        MK[i] = 0;
    }

    // 2. 计算灰度直方图
    for (uint16 i = 0; i < MT9V03X_H; i++) {
        for (uint16 j = 0; j < MT9V03X_W; j++) {
            img_temp_value = mt9v03x_image[i][j];
            hits[img_temp_value]++;
        }
    }

    // 3. 计算概率分布、累积概率、累积均值
    for (uint16 i = 0; i < Grayscale; i++) {
        P[i] = (float)hits[i] / imgsize;
        PK[i] = sumPk + P[i];
        sumPk = PK[i];
        MK[i] = sumMk + i * P[i];
        sumMk = MK[i];
    }

    // 4. 遍历所有可能的阈值，寻找使类间方差最大的阈值
    for (uint16 i = 5; i < 245; i++) {
        if (PK[i] == 0 || PK[i] == 1) {
            continue;  // 避免除以0
        }
        float numerator = MK[Grayscale - 1] * PK[i] - MK[i];
        vartmp = (numerator * numerator) / (PK[i] * (1 - PK[i]));

        if (vartmp > var) {
            var = vartmp;
            img_thrsod = i;
        }
    }

    // 5. 显示阈值并执行二值化
    tft180_show_uint(8 * 0, 16 * 7, img_thrsod, 4);
    binaryzation(BAW_images, img_thrsod);
}
